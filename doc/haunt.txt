                                                                    *haunt.nvim*
                                                                         *haunt*
  Introduction .................................................. |haunt.nvim|
  Configuration ........................................ |haunt-configuration|
  API Functions .................................................. |haunt-api|
  Bookmark Structure ........................................ |haunt-bookmark|
  Picker ...................................................... |haunt-picker|
  Sidekick .................................................. |haunt-sidekick|
  Commands .................................................. |haunt-commands|

------------------------------------------------------------------------------

# Introduction ~

haunt.nvim is a powerful and elegant bookmark management plugin for Neovim.
It allows you to mark important lines in your code, navigate between them
effortlessly, and add contextual annotations - all persisted per git branch.

Features:
  - Smart bookmarking with a single command
  - Quick navigation between bookmarks
  - Rich annotations displayed as virtual text
  - Git-aware persistence (per repository and branch)
  - Visual indicators (customizable signs and inline annotations)
  - Automatic line tracking as you edit
  - Zero configuration required

# Quick Start ~
                                                          *haunt-quickstart*

After installation, haunt.nvim works out of the box with sensible defaults.

Basic usage: >lua
  -- Add an annotation (creates bookmark if needed)
  require('haunt.api').annotate()

  -- Navigate to the next bookmark
  require('haunt.api').next()

  -- Navigate to the previous bookmark
  require('haunt.api').prev()

  -- Toggle annotation visibility
  require('haunt.api').toggle_annotation()

  -- Delete bookmark at current line
  require('haunt.api').delete()

  -- Clear all bookmarks in current file
  require('haunt.api').clear()
<

Or use the provided commands: >vim
  :HauntAnnotate
  :HauntNext
  :HauntPrev
  :HauntToggle
  :HauntDelete
  :HauntList
  :HauntClear
  :HauntClearAll
  :HauntQf
  :HauntQfAll
<

# Recommended Keymaps ~
                                                            *haunt-keymaps*
>lua
  -- Toggle bookmark annotation visibility
  vim.keymap.set('n', 'mm', function() require('haunt.api').toggle_annotation() end,
    { desc = "Toggle bookmark annotation" })

  -- Navigate bookmarks
  vim.keymap.set('n', 'mn', function() require('haunt.api').next() end,
    { desc = "Next bookmark" })
  vim.keymap.set('n', 'mp', function() require('haunt.api').prev() end,
    { desc = "Previous bookmark" })

  -- Annotate bookmark
  vim.keymap.set('n', 'ma', function() require('haunt.api').annotate() end,
    { desc = "Annotate bookmark" })

  -- Delete bookmark
  vim.keymap.set('n', 'md', function() require('haunt.api').delete() end,
    { desc = "Delete bookmark" })

  -- Clear bookmarks
  vim.keymap.set('n', 'mc', function() require('haunt.api').clear() end,
    { desc = "Clear bookmarks in file" })
  vim.keymap.set('n', 'mC', function() require('haunt.api').clear_all() end,
    { desc = "Clear all bookmarks" })

  -- List bookmarks
  vim.keymap.set('n', 'ml', function() require('haunt.picker').show() end,
    { desc = "List bookmarks" })
<

# Persistence ~
                                                         *haunt-persistence*

Bookmarks are automatically saved and loaded:
  - Location: `~/.local/share/nvim/haunt/` (or custom data_dir)
  - Format: JSON files named by git repo + branch hash
  - Auto-save: On buffer hide and Neovim exit
  - Per-branch: Each git branch has its own bookmark set

This means you can:
  - Switch branches without losing bookmarks
  - Have different bookmarks for different features
  - Share bookmark files with your team (optional)

# Troubleshooting ~
                                                      *haunt-troubleshooting*

Bookmarks not persisting: ~

Make sure you're in a git repository with an active branch.
haunt.nvim uses git to determine where to save bookmarks.
If not in a git repo, bookmarks are stored per working directory.

Signs not showing: ~

1. Verify signs are enabled in your terminal/GUI
2. Check if another plugin is using the sign column
3. Ensure your colorscheme defines the highlight groups

Bookmarks at wrong lines after editing: ~

This shouldn't happen as bookmarks use extmarks that track line changes.
If it does occur, save your bookmarks and restart Neovim.

Picker not working: ~

The picker requires Snacks.nvim (https://github.com/folke/snacks.nvim).
Install it via your plugin manager.

------------------------------------------------------------------------------
Class ~
{HauntModule}
Fields ~
{_has_potential_bookmarks} `(fun(): boolean)`
{_ensure_initialized} `(fun())`
{_setup_restoration_autocmd} `(fun())`
{setup_autocmds} `(fun())`
{setup} `(fun(opts?: HauntConfig))`
{get_config} `(fun(): HauntConfig)`
{is_setup} `(fun(): boolean)`

------------------------------------------------------------------------------
                                                                  *_initialized*
                                 `_initialized`
Type ~
`(boolean)`

------------------------------------------------------------------------------
                                                                    *save_timer*
                                  `save_timer`
Type ~
`(uv_timer_t)`

------------------------------------------------------------------------------
                                                                     *M.setup()*
                               `M.setup`({opts})
Setup function for haunt.nvim.

Initializes the plugin with user configuration. This is optional -
haunt.nvim works with zero configuration using sensible defaults.

Parameters ~
{opts} `(optional)` `(HauntConfig)` Optional configuration table. See |HauntConfig|.

Usage ~
>lua
  -- Use defaults (no setup required)
  require('haunt.api').annotate()

  -- Or customize with setup
  require('haunt').setup({
    sign = '',
    sign_hl = 'DiagnosticInfo',
    virt_text_hl = 'Comment',
  })
<
------------------------------------------------------------------------------
                                                                *M.get_config()*
                                `M.get_config`()
Get the current configuration.

Return ~
`(HauntConfig)` config The current configuration

------------------------------------------------------------------------------
                                                                  *M.is_setup()*
                                 `M.is_setup`()
Check if setup has been called.

Return ~
`(boolean)` is_setup True if setup has been called, false otherwise


==============================================================================
------------------------------------------------------------------------------
                                                           *haunt-configuration*
                                                                   *HauntConfig*

# Configuration ~

haunt.nvim works with zero configuration, but you can customize the
appearance and behavior by passing options to |haunt.setup()|.

------------------------------------------------------------------------------
Configuration options for haunt.nvim.

All fields are optional. Default values are shown below.

Class ~
{HauntConfig}


Default configuration: ~

>lua
  M.DEFAULT = {
  	sign = "󱙝",
  	sign_hl = "DiagnosticInfo",
  	virt_text_hl = "HauntAnnotation",
  	annotation_prefix = " 󰆉 ",
  	line_hl = nil,
  	virt_text_pos = "eol",
  	data_dir = nil,
  	picker_keys = {
  		delete = { key = "d", mode = { "n" } },
  		edit_annotation = { key = "a", mode = { "n" } },
  	},
  }
<
Fields ~
{sign} `(optional)` `(string)` The icon to display for bookmarks (default: '󱙝')
{sign_hl} `(optional)` `(string)` The highlight group for the sign text (default: 'DiagnosticInfo')
{virt_text_hl} `(optional)` `(string)` The highlight group for virtual text annotations (default: 'HauntAnnotation')
{annotation_prefix} `(optional)` `(string)` Text to display before the annotation (default: '  ')
{line_hl} `(optional)` `(string|nil)` The highlight group for the entire line (default: nil)
{virt_text_pos} `(optional)` `(string)` Position of virtual text: "eol" (default), "eol_right_align", "overlay", "right_align", "inline"
{data_dir} `(optional)` `(string|nil)` Custom data directory path (default: vim.fn.stdpath("data") .. "/haunt/")
{picker_keys} `(table<string, table>)` Keybindings for picker actions (default: {delete = {key = 'd', mode = {'n'}}, edit_annotation = {key = 'a', mode = {'n'}}})

------------------------------------------------------------------------------
                                                                   *user_config*
                                 `user_config`
Type ~
`(HauntConfig|nil)`


==============================================================================
------------------------------------------------------------------------------
                                                                     *haunt-api*

# API Functions ~

All API functions are available through `require('haunt.api')`.

These functions provide the core functionality for managing bookmarks:
creating, navigating, annotating, and deleting bookmarks.

------------------------------------------------------------------------------
Class ~
{ApiModule}
Fields ~
{toggle_annotation} `(fun(): boolean)`
{toggle_all_lines} `(fun(): boolean)`
{are_annotations_visible} `(fun(): boolean)`
{delete} `(fun(): boolean)`
{get_bookmarks} `(fun(): Bookmark[])`
{has_bookmarks} `(fun(): boolean)`
{load} `(fun(): boolean)`
{restore_buffer_bookmarks} `(fun(bufnr: number): boolean)`
{save} `(fun(): boolean)`
{annotate} `(fun(text?: string): boolean)`
{clear} `(fun(): boolean)`
{clear_all} `(fun(): boolean)`
{next} `(fun(): boolean)`
{prev} `(fun(): boolean)`
{delete_by_id} `(fun(bookmark_id: string): boolean)`
{to_quickfix} `(fun(opts?: QuickfixOpts): boolean)`
{yank_locations} `(fun(opts?: SidekickOpts): boolean)`
{cleanup_buffer_tracking} `(fun(bufnr: number))`
{_reset_for_testing} `(fun())`

------------------------------------------------------------------------------
                                                    *cleanup_bookmark_visuals()*
                `cleanup_bookmark_visuals`({bufnr}, {bookmark})
Clean up all visual elements for a bookmark
Removes extmarks, signs, and annotations from the buffer
Parameters ~
{bufnr} `(number)` Buffer number
{bookmark} `(Bookmark)` The bookmark whose visuals should be cleaned up

------------------------------------------------------------------------------
                                                 *create_and_persist_bookmark()*
       `create_and_persist_bookmark`({bufnr}, {filepath}, {line}, {note})
Create a bookmark with visual elements and persist it
This is a helper function to avoid code duplication between toggle_annotation() and annotate()
Parameters ~
{bufnr} `(number)` Buffer number
{filepath} `(string)` Normalized absolute file path
{line} `(number)` 1-based line number
{note} `(string|nil)` Optional annotation text
Return ~
`(boolean)` success True if bookmark was created and persisted successfully

------------------------------------------------------------------------------
                                                  *update_bookmark_annotation()*
     `update_bookmark_annotation`({bufnr}, {line}, {bookmark}, {new_note})
Update an existing bookmark's annotation
Parameters ~
{bufnr} `(number)` Buffer number
{line} `(number)` 1-based line number
{bookmark} `(Bookmark)` The bookmark to update
{new_note} `(string)` The new annotation text
Return ~
`(boolean)` success True if bookmark was updated and persisted successfully

------------------------------------------------------------------------------
                                                         *M.toggle_annotation()*
                            `M.toggle_annotation`()
Toggle annotation visibility at the current cursor position.

If a bookmark exists at the current line and has an annotation,
this will show/hide the annotation virtual text. If no annotation
exists, does nothing.

Return ~
`(boolean)` success True if toggled successfully

Usage ~
>lua
  require('haunt.api').toggle_annotation()
<
------------------------------------------------------------------------------
                                                          *M.toggle_all_lines()*
                             `M.toggle_all_lines`()
Toggle visibility of ALL annotations across ALL bookmarks.

This is useful for temporarily hiding all annotations to reduce
visual noise, then showing them again.

Return ~
`(boolean)` visible The new visibility state (true = visible, false = hidden)

Usage ~
>lua
  local visible = require('haunt.api').toggle_all_lines()
  print(visible and "Annotations shown" or "Annotations hidden")
<
------------------------------------------------------------------------------
                                                   *M.are_annotations_visible()*
                         `M.are_annotations_visible`()
Check if annotations are globally visible.

Return ~
`(boolean)` visible True if annotations should be displayed

------------------------------------------------------------------------------
                                                                    *M.delete()*
                                  `M.delete`()
Delete the bookmark at the current cursor position.

Removes the bookmark from persistence and cleans up all visual elements
(sign, extmarks, annotations).

Return ~
`(boolean)` success True if bookmark was deleted

Usage ~
>lua
  require('haunt.api').delete()
<
------------------------------------------------------------------------------
                                                                  *M.annotate()*
                              `M.annotate`({text})
Add or edit an annotation for a bookmark.

If a bookmark exists at the current line, updates its annotation.
If no bookmark exists, creates a new bookmark with the annotation.
Empty input cancels the operation.

Parameters ~
{text} `(optional)` `(string)` Optional annotation text. If provided, skips the input prompt.
Return ~
`(boolean)` success True if annotation was created/updated

Usage ~
>lua
  -- Prompt user for annotation
  require('haunt.api').annotate()

  -- Set annotation programmatically
  require('haunt.api').annotate("TODO: Fix this bug")
<
------------------------------------------------------------------------------
                                                                     *M.clear()*
                                  `M.clear`()
Clear all bookmarks in the current file.

Return ~
`(boolean)` success True if cleared successfully

Usage ~
>lua
  require('haunt.api').clear()
<
------------------------------------------------------------------------------
                                                                 *M.clear_all()*
                                `M.clear_all`()
Clear all bookmarks in the project/branch.

Shows a confirmation prompt before clearing.

Return ~
`(boolean)` success True if cleared successfully

Usage ~
>lua
  require('haunt.api').clear_all()
<
------------------------------------------------------------------------------
                                                              *M.delete_by_id()*
                        `M.delete_by_id`({bookmark_id})
Delete a bookmark by its unique ID.

This is useful for programmatic deletion without needing to navigate
to the bookmark (e.g., from the picker).

Parameters ~
{bookmark_id} `(string)` The unique ID of the bookmark to delete
Return ~
`(boolean)` success True if the bookmark was deleted

Usage ~
>lua
  local bookmarks = require('haunt.api').get_bookmarks()
  if #bookmarks > 0 then
    require('haunt.api').delete_by_id(bookmarks[1].id)
  end
<
------------------------------------------------------------------------------
                                                               *M.to_quickfix()*
                            `M.to_quickfix`({opts})
Populate the quickfix list with haunt bookmarks.

Parameters ~
{opts} `(optional)` `(QuickfixOpts)` Options for filtering and formatting
Return ~
`(boolean)` success True if the quickfix list was updated

------------------------------------------------------------------------------
                                                            *M.yank_locations()*
                           `M.yank_locations`({opts})
Yank bookmark locations to the system clipboard.

Copies all bookmarks formatted for sidekick.nvim to the unnamedplus register.
Useful for users who want to share bookmark locations without sidekick.nvim.

Parameters ~
{opts} `(optional)` `(SidekickOpts)` Options for filtering and formatting
Return ~
`(boolean)` success True if yank was successful

Usage ~
>lua
  require('haunt.api').yank_locations()

  -- Yank only current buffer bookmarks
  require('haunt.api').yank_locations({ current_buffer = true })
<
------------------------------------------------------------------------------
                                                             *M.get_bookmarks()*
                              `M.get_bookmarks`()
Get all bookmarks as a deep copy.

Returns all bookmarks currently in memory. The returned table is a
deep copy, so modifications won't affect the internal state.

Return ~
`(Bookmark[])` bookmarks Array of all bookmarks

Usage ~
>lua
  local bookmarks = require('haunt.api').get_bookmarks()
  for _, bookmark in ipairs(bookmarks) do
    print(string.format("%s:%d - %s",
      bookmark.file, bookmark.line, bookmark.note or ""))
  end
<
------------------------------------------------------------------------------
                                                             *M.has_bookmarks()*
                              `M.has_bookmarks`()
Check if any bookmarks exist.

Returns true if there are any bookmarks in memory (after loading from disk).
This is more reliable than checking package.loaded state.

Return ~
`(boolean)` has_bookmarks True if bookmarks exist, false otherwise

Usage ~
>lua
  if require('haunt.api').has_bookmarks() then
    print("Bookmarks found!")
  end
<
------------------------------------------------------------------------------
                                                                      *M.load()*
                                   `M.load`()
Load bookmarks from persistent storage. (Disk)

This is called automatically when needed. You typically don't need
to call this manually unless you want to reload bookmarks from disk.

Return ~
`(boolean)` success True if load succeeded

------------------------------------------------------------------------------
                                                                      *M.save()*
                                   `M.save`()
Save bookmarks to persistent storage.

Bookmarks are auto-saved on buffer hide and Neovim exit, but you can
call this manually to force a save.

Return ~
`(boolean)` success True if save succeeded

Usage ~
>lua
  require('haunt.api').save()
<
------------------------------------------------------------------------------
                                                                      *M.next()*
                                   `M.next`()
Jump to the next bookmark in the current buffer.

Wraps around to the first bookmark if at the end.

Return ~
`(boolean)` success True if jumped to a bookmark

Usage ~
>lua
  require('haunt.api').next()
<
------------------------------------------------------------------------------
                                                                      *M.prev()*
                                   `M.prev`()
Jump to the previous bookmark in the current buffer.

Wraps around to the last bookmark if at the beginning.

Return ~
`(boolean)` success True if jumped to a bookmark

Usage ~
>lua
  require('haunt.api').prev()
<
------------------------------------------------------------------------------
                                                  *M.restore_buffer_bookmarks()*
                     `M.restore_buffer_bookmarks`({bufnr})
Restore bookmark visuals for a specific buffer.

This is called automatically when buffers are opened. You typically
don't need to call this manually.

Parameters ~
{bufnr} `(number)` Buffer number to restore bookmarks for
Return ~
`(boolean)` success True if restoration succeeded or was skipped

------------------------------------------------------------------------------
                                                   *M.cleanup_buffer_tracking()*
                      `M.cleanup_buffer_tracking`({bufnr})
Clean up restoration tracking for a deleted buffer
This prevents memory leaks in the restored_buffers table
Parameters ~
{bufnr} `(number)` Buffer number that was deleted


==============================================================================
------------------------------------------------------------------------------
                                                                *haunt-bookmark*
                                                                      *Bookmark*

# Bookmark Structure ~

Bookmarks are stored as tables with the following fields:

------------------------------------------------------------------------------
Bookmark data structure.

Represents a single bookmark in haunt.nvim.

Class ~
{Bookmark}
Fields ~
{file} `(string)` Absolute path to the bookmarked file
{line} `(number)` 1-based line number of the bookmark
{note} `(string|nil)` Optional annotation text displayed as virtual text
{id} `(string)` Unique bookmark identifier (auto-generated)
{extmark_id} `(number|nil)` Extmark ID for line tracking (internal)
{annotation_extmark_id} `(number|nil)` Extmark ID for annotation display (internal)

------------------------------------------------------------------------------
Class ~
{PersistenceModule}
Fields ~
{set_data_dir} `(fun(dir: string))`
{ensure_data_dir} `(fun(): string|nil,)` string|nil
{get_git_info} `(fun(): {root: string|nil, branch: string|nil})`
{get_storage_path} `(fun(): string|nil,)` string|nil
{save_bookmarks} `(fun(bookmarks: Bookmark[], filepath?: string): boolean)`
{load_bookmarks} `(fun(filepath?: string): Bookmark[]|nil)`
{create_bookmark} `(fun(file: string, line: number, note?: string): Bookmark|nil,)` string|nil
{is_valid_bookmark} `(fun(bookmark: table): boolean)`

------------------------------------------------------------------------------
                                                               *_git_info_cache*
                               `_git_info_cache`
Type ~
`({root: string|nil, branch: string|nil}|nil)`

------------------------------------------------------------------------------
                                                                   *_cache_time*
                                 `_cache_time`
Type ~
`(number)`

------------------------------------------------------------------------------
                                                                     *CACHE_TTL*
                                  `CACHE_TTL`
Type ~
`(number)`

------------------------------------------------------------------------------
                                                            *_git_warning_shown*
                              `_git_warning_shown`
Type ~
`(boolean)`

------------------------------------------------------------------------------
                                                                *get_git_root()*
                                `get_git_root`()
Gets the git root directory for the current working directory
Return ~
`(string|nil)` git_root The git repository root path, or nil if not in a git repo

------------------------------------------------------------------------------
                                                              *get_git_branch()*
                               `get_git_branch`()
Gets the current git branch name
Return ~
`(string|nil)` branch The current git branch name, or nil if not in a git repo

------------------------------------------------------------------------------
                                                              *M.set_data_dir()*
                            `M.set_data_dir`({dir})
Set custom data directory
Parameters ~
{dir} `(string|nil)` Custom data directory path

------------------------------------------------------------------------------
                                                           *M.ensure_data_dir()*
                             `M.ensure_data_dir`()
Ensures the haunt data directory exists
Return ~
`(string)` data_dir The haunt data directory path

------------------------------------------------------------------------------
                                                              *M.get_git_info()*
                               `M.get_git_info`()
Get git repository information for the current working directory
Uses caching with 5-second TTL to avoid repeated system calls
@return { root: string|nil, branch: string|nil }
Returns a table with:
  - root: absolute path to git repository root, or nil if not in a git repo
  - branch: name of current branch, or nil if not in a git repo, detached HEAD, or no commits

------------------------------------------------------------------------------
                                                          *M.get_storage_path()*
                             `M.get_storage_path`()
Generates a storage path for the current git repository and branch
Uses an 8-character SHA256 hash of "repo_root|branch" for the filename
Falls back to CWD and "__default__" branch when not in a git repository
Return ~
`(string)` path The full path to the storage file

------------------------------------------------------------------------------
                                                            *M.save_bookmarks()*
                  `M.save_bookmarks`({bookmarks}, {filepath})
Save bookmarks to JSON file
Parameters ~
{bookmarks} `(table)` Array of bookmark tables to save
{filepath} `(optional)` `(string)` Optional custom file path (defaults to git-based path)
Return ~
`(boolean)` success True if save was successful, false otherwise

------------------------------------------------------------------------------
                                                            *M.load_bookmarks()*
                         `M.load_bookmarks`({filepath})
Load bookmarks from JSON file
Parameters ~
{filepath} `(optional)` `(string)` Optional custom file path (defaults to git-based path)
Return ~
`(table)` bookmarks Array of bookmarks, or empty table if file doesn't exist or on error

------------------------------------------------------------------------------
                                                        *generate_bookmark_id()*
                     `generate_bookmark_id`({file}, {line})
Generate a unique bookmark ID
@param file string Absolute path to the file
@param line number 1-based line number
@return string id A 16-character unique identifier

------------------------------------------------------------------------------
                                                           *M.create_bookmark()*
                  `M.create_bookmark`({file}, {line}, {note})
Create a new bookmark. Does NOT save it!
@param file string Absolute path to the file
@param line number 1-based line number
@param note? string Optional annotation text
@return Bookmark|nil bookmark A new bookmark table, or nil if validation fails
@return string|nil error_msg Error message if validation fails

------------------------------------------------------------------------------
                                                         *M.is_valid_bookmark()*
                       `M.is_valid_bookmark`({bookmark})
Validate a bookmark structure
@param bookmark any The value to validate
@return boolean valid True if the bookmark structure is valid


==============================================================================
------------------------------------------------------------------------------
                                                                  *haunt-picker*

# Picker ~

The picker provides an interactive interface to browse and manage bookmarks.
Requires Snacks.nvim (https://github.com/folke/snacks.nvim).

Picker actions: ~
  - `<CR>`: Jump to the selected bookmark
  - `d` (normal mode): Delete the selected bookmark
  - `a` (normal mode): Edit the bookmark's annotation

The keybindings can be customized via |HauntConfig|.picker_keys.

------------------------------------------------------------------------------
                                                                      *M.show()*
                                `M.show`({opts})
Open the bookmark picker.

Displays all bookmarks in an interactive picker powered by Snacks.nvim.
Allows jumping to, deleting, or editing bookmark annotations.

Usage ~
>lua
  -- Show the picker
  require('haunt.picker').show()

Parameters ~
{opts} `(optional)` `(snacks.picker.Config)` Options to pass to Snacks.picker


==============================================================================
------------------------------------------------------------------------------
                                                                *haunt-sidekick*

# Sidekick ~

Integration with sidekick.nvim (https://github.com/folke/sidekick.nvim).
Provides bookmark locations in a format compatible with sidekick's location system.

------------------------------------------------------------------------------
Class ~
{SidekickModule}
Fields ~
{get_locations} `(fun(opts?: SidekickOpts): string)`

------------------------------------------------------------------------------
Class ~
{SidekickOpts}
Fields ~
{current_buffer} `(optional)` `(boolean)` If true, return only bookmarks for the current buffer (default: false)
{append_annotations} `(optional)` `(boolean)` If true, append annotation text to each location (default: true)

------------------------------------------------------------------------------
                                                             *M.get_locations()*
                           `M.get_locations`({opts})
Get bookmark locations formatted for sidekick.nvim.

Returns bookmarks in sidekick-compatible format:
`- @/{path} :L{line} - "{note}"`

Parameters ~
{opts} `(optional)` `(SidekickOpts)` Options for filtering and formatting
Return ~
`(string)` # Formatted bookmark locations, one per line

Usage ~
>lua
  -- Get all bookmarks
  local sidekick = require('haunt.sidekick')
  local locations = sidekick.get_locations()

  -- Get only current buffer bookmarks
  local current = sidekick.get_locations({ current_buffer = true })


==============================================================================
------------------------------------------------------------------------------
                                                                *haunt-commands*

# Commands ~

haunt.nvim provides the following user commands:

`:HauntToggle` - Toggle bookmark annotation visibility
`:HauntAnnotate [text]` - Add or edit annotation for bookmark at cursor
`:HauntDelete` - Delete bookmark at current line
`:HauntNext` - Jump to next bookmark
`:HauntPrev` - Jump to previous bookmark
`:HauntList` - Open interactive picker to browse all bookmarks
`:HauntClear` - Clear all bookmarks in current buffer
`:HauntClearAll` - Clear all bookmarks across all files

------------------------------------------------------------------------------
Class ~
{HauntCommandInfo}
Fields ~
{fn} `(string)`
{desc} `(string)`
{has_args} `(optional)` `(boolean)`
{args} `(optional)` `(table)`

------------------------------------------------------------------------------
                                                                      *commands*
                                   `commands`
Type ~
`(table<string, HauntCommandInfo>)`


 vim:tw=78:ts=8:noet:ft=help:norl: